View(res2)
stochrick <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)) #loop through the populations
{
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
}
}
return(N)
}
print(system.time(res2<-stochrick()))
print(system.time(res2<-stochrickvect()))
sample(pval, 10000)
sample(p_val, 10000)
cor(sample(p_val, 10000))
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
load("../Data/KeyWestAnnualMeanTemperature.RData")
cor(ats$Year, ats$Temp)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(p_val)
density(p_val)
plot(density(p_val))
cor(ats$Year, ats$Temp)
apply(p_val,1, function(x) sum(abs(x) < p_obs))
p_obs <- cor(ats$Year, ats$Temp)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
apply(p_val,1, function(x) sum(abs(x) < p_obs))
Temp_lag <- matrix(rep(sample(ats$Temp), 100), nrow = 100, ncol = 100)
Temp_lag <- matrix(rep(sample(ats$Temp), 100), nrow = 100, ncol = 100)
p_val <- apply(p_val, 1, function(i)   p_val[i] <- cor(ats$Temp, Temp_lag[i,])
)
p_val <- apply(p_val, 2, function(i)   p_val[i] <- cor(ats$Temp, Temp_lag[i,]))
Temp_lag <- matrix(rep(sample(ats$Temp), 100), nrow = 100, ncol = 100)
p_val <- apply(p_val, 1, function(i)   p_val[i] <- cor(ats$Temp, Temp_lag[i,]))
p_val <- apply(p_val, 2, function(i)   p_val[i] <- cor(ats$Temp, Temp_lag[i,]))
p_val <- apply(p_val, 1, function(i)   p_val[i] <- cor(ats$Temp, Temp_lag[,i]))
p_val <- apply(p_val, 1, function(i) p_val[i] <- cor(ats$Temp, Temp_lag[,i]))
Temp_lag[,1]
Temp_lag[1,]
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
apply(p_val,1, function(x) sum(abs(x) < p_obs))
apply(p_val,1, function(x) sum(abs(p_val[x]) < p_obs))
lapply(p_val, function(x) sum(abs(p_val[x]) < p_obs))
lapply(p_val, function(x) sum(p_val[x] < p_obs))
sum(p_val < p_obs)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
sum(p_val < p_obs)
p_obs <- cor(ats$Year, ats$Temp)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
sum(p_val < p_obs)
View(res2)
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print(system.time(res2<-stochrickvect()))
View(res2)
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
View(res2)
plot(res2[1])
plot(res2[1,])
plot(res2[,1])
plot(res2[,2])
plot(res2[,3])
plot(res2[1,])
plot(res2[1,], 1:100)
stochrickvect <- function(p0=runif(100,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
View(res2)
plot(res2[1,], 1:100)
plot(res2[2,], 1:100)
plot(res2[,1], 1:100)
#initialize
N<-matrix(NA,numyears,length(p0))
N[,1]<-p0
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[,1]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[,1]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[,1]<-N[,yr-1]*exp(r*(1-N[,yr-1]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
#initialize
N<-matrix(NA,numyears,length(p0))
N[,1]<-p0
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[,1]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[,yr]<-N[,yr-1]*exp(r*(1-N[,yr-1]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
N[1,]<-p0
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[,yr]<-N[,yr-1]*exp(r*(1-N[,yr-1]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
View(res2)
plot(1:100, res2[,1])
plot(1:100, res2[,2])
plot(1:100, res2[,3])
plot(1:100, res2[,3])
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
plot(1:100, res2[,3])
plot(1:100, res2[,4])
plot(1:100, res2[,7])
plot(1:100, res2[,100])
plot(1:100, res2[,20])
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=100,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
plot(1:100, res2[,20])
plot(1:100, res2[,100])
plot(1:100, res2[,50])
stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
}
return(N)
}
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
plot(1:100, res2[,50])
plot(1:100, res2[,20])
sum(p_val < p_obs)
load("../Data/KeyWestAnnualMeanTemperature.RData")
p_obs <- cor(ats$Year, ats$Temp)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
sum(p_val < p_obs)
sum(p_val > p_obs)
load("../Data/KeyWestAnnualMeanTemperature.RData")
p_obs <- cor(ats$Year, ats$Temp)
p_val <- rep(NA, 10000)
for(i in 1:10000){
Temp_lag <- sample(ats$Temp, 100)
p_val[i] <- cor(ats$Temp, Temp_lag)
}
plot(density(p_val))
sum(p_val > p_obs)
sum(p_val > p_obs)/length(p_val)
install.packages("maps")
import(maps)
load(maps)
load(GPDDFiltered.RData)
library(maps)
load(GPDDFiltered.RData)
load("../Data/GPDDFiltered.RData")
?map(), ...)
world
data("world2MapEnv")
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
res2[,1000]
require (raster)
require (maps)
install.packages("raster")
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
View(gpdd)
?raster()
?raster()
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
library(maps)
load("../Data/GPDDFiltered.RData")
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
require (raster)
require (maps)
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
load("../Data/GPDDFiltered.RData")
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
load("../Data/GPDDFiltered.RData")
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
load("../Data/GPDDFiltered.RData")
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
load("../Data/GPDDFiltered.RData")
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
plot()
plot(r)
load("../Data/GPDDFiltered.RData")
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
?map()
map("world", col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
require (maps)
load("../Data/GPDDFiltered.RData")
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
plot.new()
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
plot.new()
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$lat, gpdd$long, col = "red", cex = .6)
library(ggplot2)
library(ggmap)
install.packages("ggmap")
View(gpdd)
?get_map()
load("../Data/GPDDFiltered.RData")
points(gpdd$long, gpdd$lat)
load("../Data/GPDDFiltered.RData")
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
require (raster)
require (maps)
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$long, gpdd$lat)
load("../Data/GPDDFiltered.RData")
map('world', fill = TRUE, col = 1:10, wrap = c(-180,180))
require (raster)
require (maps)
temp1<-matrix(data = rexp(180*360, rate = 10), nrow = 360, ncol = 180)  #random matrix
r<-raster(temp1,xmn=-179.5,xmx=179.5,ymn=-89.5,ymx=89.5,crs="+proj=longlat +datum=WGS84")
plot(r)
map("world",add=T,fill=TRUE, col="white", bg="white")
points(gpdd$long, gpdd$lat)
worldmap = ggplot(aes(x = long.recenter, y = lat), data = worldmap.cp) +
geom_polygon(aes(group = group.regroup), fill="#f9f9f9", colour = "grey65") +
scale_y_continuous(limits = c(-60, 85)) +
coord_equal() +  theme_bw() +
theme(legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
#axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
panel.border = element_rect(colour = "black"))
### Function to regroup split lines and polygons
# Takes dataframe, column with long and unique group variable, returns df with added column named group.regroup
RegroupElements <- function(df, longcol, idcol){
g <- rep(1, length(df[,longcol]))
if (diff(range(df[,longcol])) > 300) { # check if longitude within group differs more than 300 deg, ie if element was split
d <- df[,longcol] > mean(range(df[,longcol])) # we use the mean to help us separate the extreme values
g[!d] <- 1 # some marker for parts that stay in place (we cheat here a little, as we do not take into account concave polygons)
g[d] <- 2 # parts that are moved
}
g <- paste(df[, idcol], g, sep=".") # attach to id to create unique group variable for the dataset
df$group.regroup <- g
df
}
### Function to close regrouped polygons
# Takes dataframe, checks if 1st and last longitude value are the same, if not, inserts first as last and reassigns order variable
ClosePolygons <- function(df, longcol, ordercol){
if (df[1,longcol] != df[nrow(df),longcol]) {
tmp <- df[1,]
df <- rbind(df,tmp)
}
o <- c(1: nrow(df)) # rassign the order variable
df[,ordercol] <- o
df
}
# now regroup
worldmap.rg <- ddply(worldmap, .(group), RegroupElements, "long.recenter", "group")
# close polys
worldmap.cp <- ddply(worldmap.rg, .(group.regroup), ClosePolygons, "long.recenter", "order") # use the new grouping var
#############################################################################
# Plot worldmap using data from worldmap.cp
windows(9.2, 4)
worldmap = ggplot(aes(x = long.recenter, y = lat), data = worldmap.cp) +
geom_polygon(aes(group = group.regroup), fill="#f9f9f9", colour = "grey65") +
scale_y_continuous(limits = c(-60, 85)) +
coord_equal() +  theme_bw() +
theme(legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
#axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
panel.border = element_rect(colour = "black"))
# Plot the CRAN Mirrors
worldmap = worldmap + geom_point(data = Mirrors, aes(long.recenter, lat),
colour = "red", pch = 19, size = 3, alpha = .4)
# Colour New Zealand
# Take care of variable names in worldmap.cp
head(worldmap.cp)
worldmap + geom_polygon(data = subset(worldmap.cp, region == "New Zealand", select = c(long.recenter, lat, group.regroup)),
aes(x = long.recenter, y = lat, group = group.regroup), fill = "blue")
###################################################################################################
# Recentre worldmap (and Mirrors coordinates) on longitude 160
### Code by Claudia Engel  March 19, 2012, www.stanford.edu/~cengel/blog
### Recenter ####
center <- 160 # positive values only
# shift coordinates to recenter CRAN Mirrors
Mirrors$long.recenter <- ifelse(Mirrors$lon < center - 180 , Mirrors$lon + 360, Mirrors$lon)
# shift coordinates to recenter worldmap
worldmap <- map_data ("world")
worldmap$long.recenter <- ifelse(worldmap$long < center - 180 , worldmap$long + 360, worldmap$long)
### Function to regroup split lines and polygons
# Takes dataframe, column with long and unique group variable, returns df with added column named group.regroup
RegroupElements <- function(df, longcol, idcol){
g <- rep(1, length(df[,longcol]))
if (diff(range(df[,longcol])) > 300) { # check if longitude within group differs more than 300 deg, ie if element was split
d <- df[,longcol] > mean(range(df[,longcol])) # we use the mean to help us separate the extreme values
g[!d] <- 1 # some marker for parts that stay in place (we cheat here a little, as we do not take into account concave polygons)
g[d] <- 2 # parts that are moved
}
g <- paste(df[, idcol], g, sep=".") # attach to id to create unique group variable for the dataset
df$group.regroup <- g
df
}
### Function to close regrouped polygons
# Takes dataframe, checks if 1st and last longitude value are the same, if not, inserts first as last and reassigns order variable
ClosePolygons <- function(df, longcol, ordercol){
if (df[1,longcol] != df[nrow(df),longcol]) {
tmp <- df[1,]
df <- rbind(df,tmp)
}
o <- c(1: nrow(df)) # rassign the order variable
df[,ordercol] <- o
df
}
# now regroup
worldmap.rg <- ddply(worldmap, .(group), RegroupElements, "long.recenter", "group")
# close polys
worldmap.cp <- ddply(worldmap.rg, .(group.regroup), ClosePolygons, "long.recenter", "order") # use the new grouping var
#############################################################################
# Plot worldmap using data from worldmap.cp
windows(9.2, 4)
worldmap = ggplot(aes(x = long.recenter, y = lat), data = worldmap.cp) +
geom_polygon(aes(group = group.regroup), fill="#f9f9f9", colour = "grey65") +
scale_y_continuous(limits = c(-60, 85)) +
coord_equal() +  theme_bw() +
theme(legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
#axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
panel.border = element_rect(colour = "black"))
# Plot the CRAN Mirrors
worldmap = worldmap + geom_point(data = Mirrors, aes(long.recenter, lat),
colour = "red", pch = 19, size = 3, alpha = .4)
# Colour New Zealand
# Take care of variable names in worldmap.cp
head(worldmap.cp)
worldmap + geom_polygon(data = subset(worldmap.cp, region == "New Zealand", select = c(long.recenter, lat, group.regroup)),
aes(x = long.recenter, y = lat, group = group.regroup), fill = "blue")
